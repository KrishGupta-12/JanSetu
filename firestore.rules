/**
 * @fileoverview Firestore Security Rules for JanSetu Application
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, role-based access control model.
 * It enforces user-ownership for citizen data and admin-only access for administrative data.
 * All write operations are strictly controlled and validated against the authenticated user's identity.
 * Read operations follow a principle of least privilege, with public read access where appropriate and owner-only or admin-only access for sensitive data.
 *
 * Data Structure:
 * - /citizens/{citizenId}: Stores citizen profiles, accessible only to the owning citizen.
 * - /admins/{adminId}: Stores admin profiles, granting elevated privileges based on existence.
 * - /issue_reports/{issueReportId}: Stores all issue reports, with public read and owner-only write access.
 * - /users/{userId}/issue_reports/{issueReportId}: Stores issue reports specific to a user; duplicates data in /issue_reports.
 * - /air_quality_sensors/{sensorId}: Stores air quality sensor data, publicly readable.
 * - /disaster_alerts/{alertId}: Stores disaster alert information, publicly readable.
 *
 * Key Security Decisions:
 * - Listing of citizens is disallowed.
 * - Admin privileges are granted based on the existence of a document in the /admins collection.
 * - Read-only collections (air_quality_sensors, disaster_alerts) are publicly readable.
 * - All write operations require authentication.
 *
 * Denormalization for Authorization:
 * - IssueReport documents contain both `citizenId` and `assignedAdminId` to avoid costly `get()` calls when evaluating permissions.
 *
 * Structural Segregation:
 * - Issue reports are stored in two locations for different access patterns: a top-level collection for general access and a user subcollection for user-specific lists.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces strict user-ownership for citizen profiles.
     * @path /citizens/{citizenId}
     * @allow (create) - A citizen can create their profile if the citizenId matches their auth.uid.
     * @allow (get, update, delete) - A citizen can only get, update or delete their own profile.
     * @deny (create) - Another user attempts to create a citizen profile using someone else's uid.
     * @deny (list) -  No listing of all citizen documents is allowed.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /citizens/{citizenId} {
      function isOwner(citizenId) {
        return request.auth.uid == citizenId;
      }
      function isExistingOwner(citizenId) {
        return isOwner(citizenId) && resource != null;
      }
      allow get: if isOwner(citizenId);
      allow list: if false;
      allow create: if isOwner(citizenId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(citizenId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(citizenId);
    }

    /**
     * @description Grants admin privileges based on document existence in the /admins collection.
     * @path /admins/{adminId}
     * @allow (get) - Any authenticated user can read an admin profile.
     * @allow (create) - Only an admin (determined by a separate process, not rule) can create an admin profile.
     * @allow (update, delete) - Only the admin themselves can update or delete their profile.
     * @deny (list) - Listing of all admin documents is not allowed.
     * @principle Restricts admin management to authorized personnel.
     */
    match /admins/{adminId} {
      function isAdmin(adminId) {
        return request.auth.uid == adminId;
      }
      function isExistingAdmin(adminId) {
        return isAdmin(adminId) && resource != null;
      }
      allow get: if isAdmin(adminId);
      allow list: if false;
      allow create: if isAdmin(adminId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingAdmin(adminId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingAdmin(adminId);
    }

    /**
     * @description Controls access to issue reports. Public read, owner-only write.
     * @path /issue_reports/{issueReportId}
     * @allow (get, list) - Any user can read or list issue reports.
     * @allow (create) - A user can create an issue report if the citizenId field matches their auth.uid.
     * @allow (update, delete) - Only the owner of the issue report can update or delete it, and the document must exist.
     * @deny (create) - A user cannot create an issue report with a citizenId that doesn't match their own.
     * @principle Allows public access to issue reports, but restricts modification and deletion to the owner.
     */
    match /issue_reports/{issueReportId} {
      function isOwner(citizenId) {
        return request.auth.uid == citizenId;
      }
      function isExistingOwner(citizenId) {
        return isOwner(citizenId) && resource != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.citizenId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.citizenId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.citizenId);
    }

    /**
     * @description Secures issue reports specific to a user.
     * @path /users/{userId}/issue_reports/{issueReportId}
     * @allow (get, list) - The owner (user) of the reports can list and get them.
     * @allow (create) - A user can create an issue report under their user ID, as long as the citizenId is correct
     * @allow (update, delete) - Only the owner can update or delete their issue reports, and the document must exist.
     * @deny (create) - A user cannot create an issue report under another user's ID.
     * @principle Enforces ownership for user-specific issue reports, mirroring data from the top-level collection.
     */
    match /users/{userId}/issue_reports/{issueReportId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.citizenId == request.auth.uid;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to air quality sensor data.
     * @path /air_quality_sensors/{sensorId}
     * @allow (get, list) - Any user can read or list air quality sensor data.
     * @deny (create, update, delete) - No user can create, update, or delete air quality sensor data without authentication.
     * @principle Provides public read access to sensor data while restricting write access.
     */
    match /air_quality_sensors/{sensorId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to disaster alert information.
     * @path /disaster_alerts/{alertId}
     * @allow (get, list) - Any user can read or list disaster alert information.
     * @deny (create, update, delete) - No user can create, update, or delete disaster alert information without authentication.
     * @principle Provides public read access to disaster alerts while restricting write access.
     */
    match /disaster_alerts/{alertId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

  }

  function isSignedIn() {
    return request.auth != null;
  }
}