/**
 * @fileoverview Firestore Security Rules for the Citizen Engagement Platform.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data protection by enforcing strict ownership-based access control for user profiles.
 * Public data, such as issue reports, are readable by everyone but writable only by authorized users (either the original submitter or an admin).
 * Admin privileges are determined by the presence of a document in the `/superAdmins` collection, ensuring a clear and auditable mechanism for role management.
 *
 * Data Structure:
 * - `/users/{userId}`: Stores user profile data.  Access is restricted to the user themselves.
 * - `/issueReports/{reportId}`: Stores issue reports. Publicly readable, but only writable by the submitter or an admin.
 * - `/superAdmins/{userId}`:  Presence of a document grants super admin privileges to the corresponding user.
 * - `/alerts/{alertId}`: Stores platform-wide alerts.  Writable only by administrators.
 * - `/leaderboard/{leaderboardId}`: Stores pre-calculated leaderboard data. Publicly readable.
 *
 * Key Security Decisions:
 * - Listing of users is explicitly denied to prevent information disclosure.
 * - Admin privileges are granted based on the existence of a document in the `/superAdmins` collection.
 * - All write operations require user authentication.
 *
 * Denormalization for Authorization:
 *  - Super Admin role is determined by the existence of a document in the `/superAdmins` collection with document ID matching request.auth.uid, eliminating the need for custom claims or separate role management.
 *
 * Structural Segregation:
 * - Uses separate collections for user profiles (`/users/{userId}`) and public content (`/issueReports/{reportId}`) to avoid the need for complex filtering based on privacy flags.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles.  Only the user themselves can read or write their own profile. Listing all users is denied.
     * @path /users/{userId}
     * @allow (read, write) if the requesting user's UID matches the userId in the path.
     * @deny (read, write) if the requesting user's UID does not match the userId in the path.
     * @principle Enforces document ownership for reads and writes.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // Listing users is not permitted.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Stores all issue reports submitted by citizens. Publicly readable, but only writable by the submitter or an admin.
     * @path /issueReports/{reportId}
     * @allow (get, list) anyone can read all issue reports.
     * @allow (create) only the report submitter can create an issue report. The citizenId field must match their UID.
     * @allow (update, delete) only the report submitter or an admin can update or delete an issue report.
     * @deny (create, update, delete) if the user is not authenticated.
     * @principle Public read access with owner-only or admin-only writes.
     */
    match /issueReports/{reportId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.citizenId == request.auth.uid;
      allow update: if isSignedIn() && (isOwner(resource.data.citizenId) || isSuperAdmin());
      allow delete: if isSignedIn() && (isOwner(resource.data.citizenId) || isSuperAdmin());
    }

    /**
     * @description Grants super admin privileges to a user based on the existence of a document with their UID as the document ID.
     * @path /superAdmins/{userId}
     * @allow (read, write, create, update, delete) only the super admin can manage this collection.
     * @principle Grants admin privileges based on document existence.
     */
    match /superAdmins/{userId} {
      allow get: if isSuperAdmin();
      allow list: if false; // Prevent listing of super admins
      allow create: if isSuperAdmin();
      allow update: if isSuperAdmin();
      allow delete: if isSuperAdmin();
    }

    /**
     * @description Stores all platform-wide alerts published by administrators. Only admins can create alerts.
     * @path /alerts/{alertId}
     * @allow (get, list) anyone can view alerts.
     * @allow (create) only admins can create alerts. The adminId field must match their UID.
     * @deny (create) if the user is not an admin.
     * @principle Admin-only write access for platform-wide alerts.
     */
    match /alerts/{alertId} {
      allow get, list: if true;
      allow create: if isSignedIn() && isSuperAdmin() && request.resource.data.adminId == request.auth.uid;
      allow update: if false; // Alerts should not be editable after creation
      allow delete: if false; // Alerts should not be deletable by anyone
    }

    /**
     * @description Stores the pre-calculated leaderboard data.  Publicly readable.
     * @path /leaderboard/{leaderboardId}
     * @allow (get, list) anyone can view the leaderboard.
     * @deny (create, update, delete) no one can create, update, or delete the leaderboard through client-side rules.
     * @principle Public read access for leaderboard data.
     */
    match /leaderboard/{leaderboardId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    // --- Helper Functions ---

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the requesting user is the owner of the document.
     * @param {string} userId The UID of the document owner.
     * @return {boolean} True if the requesting user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the requesting user is the owner of the document and that the document exists.
     * @param {string} userId The UID of the document owner.
     * @return {boolean} True if the requesting user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the requesting user is a super admin by verifying that a document exists in the `/superAdmins` collection with their UID.
     * @return {boolean} True if the requesting user is a super admin, false otherwise.
     */
    function isSuperAdmin() {
      return exists(/databases/$(database)/documents/superAdmins/$(request.auth.uid));
    }
  }
}