/**
 * @fileoverview Firestore Security Rules for JanSetu application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for citizen data and issue reports,
 * with an additional layer of admin-based access control for issue reports. Admin privileges
 * are granted based on the existence of a document in the `/admins/{adminId}` collection.
 *
 * Data Structure:
 * - /citizens/{citizenId}: Stores citizen profile data; accessible only by the citizen themselves.
 * - /admins/{adminId}: Stores admin profile data; existence grants admin privileges.
 * - /issue_reports/{issueReportId}: Stores all issue reports; read-only for all, create for signed-in users, update/delete restricted to admins or the report creator.
 * - /users/{userId}/issue_reports/{issueReportId}: Stores issue reports specific to a given user; accessible only by the user themselves.
 * - /air_quality_sensors/{sensorId}: Stores air quality sensor data; publicly readable.
 * - /disaster_alerts/{alertId}: Stores disaster alert information; publicly readable.
 *
 * Key Security Decisions:
 * - Citizen data is strictly private and only accessible by the authenticated user with a matching ID.
 * - Listing of all citizens is disallowed for privacy.
 * - Admin privileges are determined by the existence of a document in the `/admins/{adminId}` collection.
 * - Issue reports are publicly readable, but creation, update, and deletion are restricted.
 * - Air quality sensor data and disaster alerts are publicly readable.
 *
 * Denormalization for Authorization:
 * - IssueReport documents contain the `citizenId` of the reporter to avoid requiring `get()` calls
 *   on the `/citizens` collection for authorization.
 * - IssueReport documents contain the `assignedAdminId` of the assigned admin to avoid requiring `get()` calls
 *   on the `/admins` collection for authorization.
 *
 * Structural Segregation:
 * - Issue reports are stored in both a top-level collection (`/issue_reports`) for public access
 *   and in user-specific subcollections (`/users/{userId}/issue_reports`) for private, user-owned access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects citizen user data, allowing only the owner to read and write.
     * @path /citizens/{citizenId}
     * @allow (create, get, update, delete) if request.auth.uid == citizenId
     * @deny (create, get, update, delete) if request.auth.uid != citizenId
     * @principle Enforces document ownership for writes.
     */
    match /citizens/{citizenId} {
      function isOwner(citizenId) {
        return request.auth.uid == citizenId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn() && isOwner(citizenId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(citizenId);
      allow update: if isSignedIn() && isOwner(citizenId);
      allow delete: if isSignedIn() && isOwner(citizenId);
    }

    /**
     * @description Protects admin user data. Existence in this collection grants admin privileges.
     * @path /admins/{adminId}
     * @allow (create, get, update, delete) if request.auth.uid == adminId
     * @deny (create, get, update, delete) if request.auth.uid != adminId
     * @principle Enforces document ownership for writes, implies admin priviledge.
     */
    match /admins/{adminId} {
      function isOwner(adminId) {
        return request.auth.uid == adminId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn() && isOwner(adminId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(adminId);
      allow update: if isSignedIn() && isOwner(adminId);
      allow delete: if isSignedIn() && isOwner(adminId);
    }

    /**
     * @description Stores issue reports submitted by citizens.
     * @path /issue_reports/{issueReportId}
     * @allow (get, list) Everyone can read.
     * @allow (create) Signed in users can create, enforcing citizenId == request.auth.uid.
     * @allow (update, delete) Only admins or the report creator can modify.
     * @deny (update, delete) if not an admin and not the report creator.
     * @principle Public read with owner-only writes, admin override.
     */
    match /issue_reports/{issueReportId} {
      function isOwner(citizenId) {
        return request.auth.uid == citizenId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      function isAdmin() {
        return exists(/databases/$(database)/documents/admins/$(request.auth.uid));
      }
      function isExistingOwner(citizenId) {
          return isOwner(citizenId) && resource.data.citizenId == citizenId;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.citizenId == request.auth.uid;
      allow update: if isSignedIn() && (isAdmin() || isExistingOwner(request.auth.uid));
      allow delete: if isSignedIn() && (isAdmin() || isExistingOwner(request.auth.uid));
    }

     /**
      * @description Stores issue reports specific to a given user. This duplicates the issue reports data from the /issue_reports collection.
      * @path /users/{userId}/issue_reports/{issueReportId}
      * @allow (create, get, update, delete, list) Only the owner can manage their own issue reports.
      * @deny (create, get, update, delete, list) If the user ID in the path does not match the authenticated user ID.
      * @principle Enforces document ownership for writes.
      */
    match /users/{userId}/issue_reports/{issueReportId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
       function isExistingOwner(userId) {
          return isOwner(userId) && resource.data.citizenId == request.auth.uid;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.citizenId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Stores air quality sensor data.
     * @path /air_quality_sensors/{sensorId}
     * @allow (get, list) Publicly readable.
     * @deny (create, update, delete) Not allowed.
     * @principle Public read.
     */
    match /air_quality_sensors/{sensorId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores disaster alert information.
     * @path /disaster_alerts/{alertId}
     * @allow (get, list) Publicly readable.
     * @deny (create, update, delete) Not allowed.
     * @principle Public read.
     */
    match /disaster_alerts/{alertId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}