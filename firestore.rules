/**
 * @fileoverview Firestore Security Rules for the Citizen Engagement Platform.
 *
 * Core Philosophy:
 * This ruleset employs a hybrid security model, balancing open access for public content with strict ownership and role-based access controls for private and administrative data.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible to the owner and, potentially, admins.
 * - /issueReports/{reportId}: Stores citizen-submitted issue reports, publicly readable but owner-editable.
 * - /admins/{email}:  Stores admin credentials, accessible only for reading by super admins to manage other admins.
 * - /alerts/{alertId}: Stores platform alerts, publicly readable, and creatable/manageable only by admins.
 *
 * Key Security Decisions:
 * - User profiles are owner-readable/writable.
 * - Issue reports are publicly readable but writable only by the owner.
 * - Admin credentials are only manageable by super admins.
 * - Listing all users is not permitted (privacy).
 *
 * Denormalization for Authorization:
 * - Issue reports are assumed to contain a `citizenId` field that matches the UID of the user who created it, enabling owner-only write access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profiles. Users can read and write their own profiles.
     * @path /users/{userId}
     * @allow (get, update, delete) User with UID 'user123' can read/write their own profile document.
     * @allow (create) User with UID 'user123' can create their own profile document if request.auth.uid == 'user123'.
     * @deny (get) User with UID 'user456' cannot read profile document of user 'user123'.
     * @deny (create) User with UID 'user456' cannot create profile document for user 'user123'.
     * @principle Enforces document ownership; users can only manage their own profiles.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && existsAfter(/databases/$(database)/documents/users/$(userId));
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages issue reports. Issue reports are publicly readable, but only the owner can modify or delete them.
     * @path /issueReports/{reportId}
     * @allow (get, list) Any user can read any issue report.
     * @allow (create) User with UID 'user123' can create an issue report if request.resource.data.citizenId == 'user123'.
     * @allow (update, delete) User with UID 'user123' can update/delete an issue report they own.
     * @deny (create) User with UID 'user456' cannot create an issue report for user 'user123'.
     * @deny (update, delete) User with UID 'user456' cannot update/delete issue report owned by user 'user123'.
     * @principle Public read access with owner-only write access.
     */
    match /issueReports/{reportId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(citizenId) {
        return request.auth.uid == citizenId;
      }

      function isExistingOwner(citizenId) {
        return isOwner(citizenId) && get(/databases/$(database)/documents/issueReports/$(reportId)).data.citizenId == request.auth.uid;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.citizenId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(request.auth.uid);
      allow delete: if isSignedIn() && isExistingOwner(request.auth.uid);
    }

    /**
     * @description Manages admin credentials. Only super admins can manage other admin credentials.
     * @path /admins/{email}
     * @allow (get) A super admin can read any admin's credentials.
     * @allow (create, update, delete) Only super admins can manage admin credentials.
     * @deny (get) A non-super admin cannot read other admin credentials.
     * @principle Role-based access control; super admins manage other admins.
     */
    match /admins/{email} {
          function isSignedIn() {
        return request.auth != null;
      }
      function isSuperAdmin() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'super_admin';
      }

      allow get: if isSignedIn() && isSuperAdmin();
      allow list: if false;
      allow create: if isSignedIn() && isSuperAdmin();
      allow update: if isSignedIn() && isSuperAdmin();
      allow delete: if isSignedIn() && isSuperAdmin();
    }

    /**
     * @description Manages platform alerts. Alerts are publicly readable, but only admins can create them.
     * @path /alerts/{alertId}
     * @allow (get, list) Any user can read any platform alert.
     * @allow (create) Only admins can create alerts.
     * @deny (update, delete) Non-admins cannot modify or delete alerts.
     * @principle Public read access with admin-only write access.
     */
    match /alerts/{alertId} {
           function isSignedIn() {
        return request.auth != null;
      }
      function isAdmin() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'super_admin' || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'waste_admin' || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'pothole_admin' || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'streetlight_admin' || get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'water_admin';
      }

      allow get, list: if true;
      allow create: if isSignedIn() && isAdmin();
      allow update: if false;
      allow delete: if false;
    }
  }
}