{
  "entities": {
    "IssueReport": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "IssueReport",
      "type": "object",
      "description": "Represents a reported issue by a citizen.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the issue report."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N IssueReport)"
        },
        "category": {
          "type": "string",
          "description": "Category of the reported issue (e.g., waste, pothole)."
        },
        "description": {
          "type": "string",
          "description": "Detailed description of the issue."
        },
        "latitude": {
          "type": "number",
          "description": "Latitude of the issue's location."
        },
        "longitude": {
          "type": "number",
          "description": "Longitude of the issue's location."
        },
        "imageUrl": {
          "type": "string",
          "description": "URL of the uploaded image related to the issue."
        },
        "status": {
          "type": "string",
          "description": "Current status of the issue report (e.g., reported, assigned, resolved)."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the issue was reported.",
          "format": "date-time"
        },
        "assignedAdminId": {
          "type": "string",
          "description": "Reference to AdminUser. (Relationship: AdminUser 1:N IssueReport). Nullable if not assigned."
        }
      },
      "required": [
        "id",
        "userId",
        "category",
        "description",
        "latitude",
        "longitude",
        "imageUrl",
        "status",
        "createdAt"
      ]
    },
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a citizen user of the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the user."
        },
        "name": {
          "type": "string",
          "description": "Name of the user."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "phone": {
          "type": "string",
          "description": "Phone number of the user."
        },
        "location": {
          "type": "string",
          "description": "Location of the user."
        },
        "disasterAlertSubscription": {
          "type": "boolean",
          "description": "Is user subscribed to disaster alerts"
        }
      },
      "required": [
        "id",
        "name",
        "email",
        "phone"
      ]
    },
    "AdminUser": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AdminUser",
      "type": "object",
      "description": "Represents an administrative user of the application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the admin user."
        },
        "name": {
          "type": "string",
          "description": "Name of the admin user."
        },
        "email": {
          "type": "string",
          "description": "Email address of the admin user.",
          "format": "email"
        },
        "role": {
          "type": "string",
          "description": "Role of the admin user (e.g., admin, superadmin)."
        }
      },
      "required": [
        "id",
        "name",
        "email",
        "role"
      ]
    },
    "AQISensor": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AQISensor",
      "type": "object",
      "description": "Represents an Air Quality Index (AQI) sensor.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the AQI sensor."
        },
        "latitude": {
          "type": "number",
          "description": "Latitude of the sensor's location."
        },
        "longitude": {
          "type": "number",
          "description": "Longitude of the sensor's location."
        },
        "aqiValue": {
          "type": "number",
          "description": "Current AQI value reported by the sensor."
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of the AQI reading.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "latitude",
        "longitude",
        "aqiValue",
        "timestamp"
      ]
    },
    "DisasterAlert": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "DisasterAlert",
      "type": "object",
      "description": "Represents a disaster alert notification.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the disaster alert."
        },
        "message": {
          "type": "string",
          "description": "Message content of the disaster alert."
        },
        "polygonCoordinates": {
          "type": "array",
          "description": "Array of lat/long coordinates defining the geographical polygon of the affected zone.",
          "items": {
            "type": "string"
          }
        },
        "sentAt": {
          "type": "string",
          "description": "Timestamp indicating when the alert was sent.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "message",
        "polygonCoordinates",
        "sentAt"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information. Path-based ownership ensures only the user or authorized admins can access user data.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/issueReports/{issueReportId}",
        "definition": {
          "entityName": "IssueReport",
          "schema": {
            "$ref": "#/backend/entities/IssueReport"
          },
          "description": "Stores issue reports created by the user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user who created the issue report."
            },
            {
              "name": "issueReportId",
              "description": "The unique identifier for the issue report."
            }
          ]
        }
      },
      {
        "path": "/adminUsers/{adminUserId}",
        "definition": {
          "entityName": "AdminUser",
          "schema": {
            "$ref": "#/backend/entities/AdminUser"
          },
          "description": "Stores admin user profile information. Existence of a document here grants admin privileges.",
          "params": [
            {
              "name": "adminUserId",
              "description": "The unique identifier for the admin user."
            }
          ]
        }
      },
      {
        "path": "/aqiSensors/{aqiSensorId}",
        "definition": {
          "entityName": "AQISensor",
          "schema": {
            "$ref": "#/backend/entities/AQISensor"
          },
          "description": "Stores data for AQI sensors.",
          "params": [
            {
              "name": "aqiSensorId",
              "description": "The unique identifier for the AQI sensor."
            }
          ]
        }
      },
      {
        "path": "/disasterAlerts/{disasterAlertId}",
        "definition": {
          "entityName": "DisasterAlert",
          "schema": {
            "$ref": "#/backend/entities/DisasterAlert"
          },
          "description": "Stores disaster alert information.",
          "params": [
            {
              "name": "disasterAlertId",
              "description": "The unique identifier for the disaster alert."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to ensure authorization independence, clarity, and scalability, aligning with the specified principles. It leverages denormalization and structural segregation to optimize security rules and query performance.\n\n**Authorization Independence:**\n\n*   **Issue Reports:** The `issueReports` subcollection under each user includes the `userId` of the user. This denormalization is crucial. Although `assignedAdminId` is on the document, admins have global read access, so no membership map is required. By storing the relevant user ID directly in the issue report document, rules can validate ownership (`request.auth.uid == resource.data.userId`) without needing to perform costly `get()` operations to fetch the user's data.\n\n**Structural Segregation:**\n\n*   User data is stored in `/users/{userId}` ensuring that only the user or authorized admins can access it.  \n*   Admin user data is stored in `/adminUsers/{adminUserId}`, so only they have access to edit the data.\n\n**Access Modeling:**\n\n*   **Private Data:** User profiles are located under `/users/{userId}`, following the Path-Based ownership model.  Issue reports are also created this way to support the 1:N relationship.\n*   **Global Roles (DBAC):** Admin status is granted via documents in the `/adminUsers/{adminUserId}` collection. This supports `exists()` checks in security rules.\n\n**QAPs (Rules Are Not Filters):**\n\n*   The segregation of user and admin data into distinct collections enables secure `list` operations. Rules can efficiently filter based on path without inspecting document content, preventing the need to write complex, inefficient filtering logic within the rules themselves.\n\n**Invariants:**\n\n*   Timestamps are included for auditability and can be used in security rules to enforce time-based restrictions if necessary.\n*   The structure supports maintaining the integrity of ownership and preventing unauthorized modifications."
  }
}